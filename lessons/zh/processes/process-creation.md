---
index: 4
lang: "zh"
title: "进程创建"
meta_title: "进程创建 - 进程"
meta_description: "了解 Linux 进程创建、fork 以及父/子进程。理解 PID、PPID 和 init 进程。获取 Linux 进程管理的初学者指南。"
meta_keywords: "Linux 进程创建，fork, PID, PPID, init 进程，Linux 进程，初学者，教程，指南"
---

## Lesson Content

同样，本节课和下一节课纯粹是信息性的，旨在让您了解其内部机制。一旦您对进程有了更多了解，可以随时回顾本节内容。

当创建一个新进程时，一个现有进程基本上会使用一种称为 `fork` 系统调用（系统调用将在遥远的未来讨论）的方式克隆自身。`fork` 系统调用会创建一个几乎完全相同的子进程。这个子进程会获得一个新的进程 ID (PID)，而原始进程则成为其父进程，并拥有一个称为父进程 ID **PPID** 的东西。之后，子进程可以继续使用其父进程之前使用的相同程序，或者更常见的是，使用 `execve` 系统调用启动一个新程序。这个系统调用会销毁内核为该进程设置的内存管理，并为新程序设置新的内存管理。

我们可以看到它的实际运行：

```bash
ps l
```

`l` 选项为我们提供了“长格式”或更详细的运行进程视图。您会看到一个标有 **PPID** 的列；这就是父 ID。现在看看您的终端；您会看到一个正在运行的进程，那就是您的 shell。因此，在我的系统上，我有一个正在运行 `bash` 的进程。现在请记住，当您运行 `ps l` 命令时，您是从运行 `bash` 的进程中运行它的。您会看到 `bash` shell 的 **PID** 是 `ps l` 命令的 **PPID**。

所以如果每个进程都必须有一个父进程，并且它们只是彼此的 fork，那么一定存在一个所有进程的母亲，对吗？您说得对。当系统启动时，内核会创建一个名为 **init** 的进程；它的 PID 是 1。`init` 进程除非系统关闭，否则无法终止。它以 root 权限运行，并运行许多维持系统运行的进程。我们将在系统启动课程中更详细地了解 `init`；目前，您只需知道它是所有其他进程的生成者。

## Exercise

查看您正在运行的进程。您能看到哪些其他进程有父进程吗？

## Quiz Question

What system call creates a new process?

## Quiz Answer

fork
