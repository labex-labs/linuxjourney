---
index: 4
lang: "zh"
title: "进程创建"
meta_title: "进程创建 - 进程"
meta_description: "了解 Linux 进程创建、fork 以及父/子进程。理解 PID、PPID 和 init 进程。获取 Linux 进程管理的初学者指南。"
meta_keywords: "Linux 进程创建，fork, PID, PPID, init 进程，Linux 进程，初学者，教程，指南"
---

## Lesson Content

同样，本课和下一课纯粹是信息性的，让您了解幕后发生的事情。一旦您对进程有了更多的了解，可以随时回来复习。

当一个新进程被创建时，一个现有进程基本上会使用一个称为 `fork` 系统调用（系统调用将在很久以后讨论）的东西来克隆自己。`fork` 系统调用会创建一个几乎完全相同的子进程。这个子进程会获得一个新的进程 ID (PID)，而原始进程则成为其父进程，并拥有一个称为父进程 ID **PPID** 的东西。之后，子进程可以继续使用其父进程之前使用的相同程序，或者更常见的是，使用 `execve` 系统调用来启动一个新程序。这个系统调用会销毁内核为该进程设置的内存管理，并为新程序设置新的内存管理。

我们可以看到它的实际运行情况：

```bash
ps l
```

`l` 选项为我们提供了“长格式”或更详细的运行进程视图。您会看到一个标记为 **PPID** 的列；这是父 ID。现在看看您的终端；您会看到一个正在运行的进程，它是您的 shell。因此，在我的系统上，我有一个正在运行 `bash` 的进程。现在请记住，当您运行 `ps l` 命令时，您是从运行 `bash` 的进程中运行它的。您会看到 `bash` shell 的 **PID** 是 `ps l` 命令的 **PPID**。

所以如果每个进程都必须有一个父进程，并且它们只是彼此的 fork，那么一定有一个所有进程的母亲，对吗？您说对了。当系统启动时，内核会创建一个名为 **init** 的进程；它的 PID 是 1。`init` 进程除非系统关闭，否则无法终止。它以 root 权限运行，并运行许多保持系统运行的进程。我们将在系统启动课程中更详细地了解 `init`；现在，只需知道它是所有其他进程的生成者。

## Exercise

熟能生巧！这是一个动手实验，旨在巩固您对 Linux 进程及其管理的理解：

- **[管理和监控 Linux 进程](https://labex.io/zh/labs/comptia-manage-and-monitor-linux-processes-590864)** - 在此实验中，您将学习在 Linux 系统上管理和监控进程的基本技能。您将探索如何与前台和后台进程交互，使用 `ps` 检查它们，使用 `top` 监控资源，使用 `renice` 调整优先级，以及使用 `kill` 终止它们。

此实验将帮助您在实际场景中应用进程 ID、父进程 ID 和进程监控的概念，并增强您对进程管理的信心。

## Quiz Question

哪个系统调用会创建一个新进程？

## Quiz Answer

fork
