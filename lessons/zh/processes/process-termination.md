---
index: 5
lang: "zh"
title: "进程终止"
meta_title: "进程终止 - 进程"
meta_description: "了解 Linux 进程终止，包括孤儿进程和僵尸进程。理解 _exit 和 wait 系统调用以实现有效的进程管理。"
meta_keywords: "Linux 进程终止，僵尸进程，孤儿进程，wait 系统调用，_exit, Linux 教程，Linux 初学者"
---

## Lesson Content

既然我们知道了进程创建时会发生什么，那么当我们不再需要它时会发生什么呢？请注意，有时 Linux 可能会变得有点“黑暗”……

进程可以使用 `_exit` 系统调用退出。这将释放该进程正在使用的资源以供重新分配。因此，当一个进程准备终止时，它会通过一个称为终止状态的东西告知内核它终止的原因。最常见的是，状态 0 表示进程成功。然而，这不足以完全终止一个进程。父进程必须使用 `wait` 系统调用来确认子进程的终止，而这会检查子进程的终止状态。我知道这听起来很可怕，但 `wait` 调用是必需的；毕竟，哪个父母不想知道他们的孩子是如何“死亡”的呢？

还有另一种终止进程的方法，那就是使用信号，我们很快就会讨论。

### 孤儿进程

当父进程在子进程之前终止时，内核知道它不会收到 `wait` 调用，因此它会将这些进程变为“孤儿”，并将它们置于 `init`（记住，所有进程之母）的照管之下。`init` 最终会为这些孤儿执行 `wait` 系统调用，以便它们可以“死亡”。

### 僵尸进程

当子进程终止而父进程尚未调用 `wait` 时会发生什么？我们仍然希望能够看到子进程是如何终止的，所以即使子进程已经完成，内核也会将子进程变成僵尸进程。子进程使用的资源仍然会释放给其他进程；但是，进程表中仍然存在此僵尸进程的条目。僵尸进程也无法被杀死，因为它们在技术上是“死的”，所以你不能使用信号来杀死它们。最终，如果父进程调用 `wait` 系统调用，僵尸进程就会消失；这被称为“收割”。如果父进程不执行 `wait` 调用，`init` 将收养僵尸进程并自动执行 `wait` 并移除僵尸进程。僵尸进程过多可能是一件坏事，因为它们会占用进程表中的空间；如果进程表满了，它将阻止其他进程运行。

## Exercise

熟能生巧！以下是一些动手实验，以加深您对 Linux 进程及其管理的理解：

1. **[管理和监控 Linux 进程](https://labex.io/zh/labs/comptia-manage-and-monitor-linux-processes-590864)** - 练习与前台和后台进程交互，使用 `ps` 检查它们，使用 `top` 监控资源，使用 `renice` 调整优先级，以及使用 `kill` 终止它们。本实验将为您提供进程生命周期的实践经验，包括如何终止它们。

本实验将帮助您在实际场景中应用进程管理和终止的概念，并增强您对 Linux 系统管理的信心。

## Quiz Question

进程成功时最常见的终止状态是什么？

## Quiz Answer

0
