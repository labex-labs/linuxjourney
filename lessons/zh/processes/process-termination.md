---
lang: "zh"
title: "进程终止"
meta_description: "了解 Linux 进程终止，包括孤儿进程和僵尸进程。理解 _exit 和 wait 系统调用以进行有效的进程管理。"
meta_keywords: "Linux 进程终止，僵尸进程，孤儿进程，wait 系统调用，_exit, Linux 教程，Linux 初学者"
---

## Lesson Content

既然我们知道了进程创建时会发生什么，那么当我们不再需要它时，又会发生什么呢？请注意，有时 Linux 会变得有点“黑暗”...

一个进程可以使用 `_exit` 系统调用退出。这将释放该进程正在使用的资源以供重新分配。因此，当一个进程准备终止时，它会通过一个称为终止状态的东西告知内核它终止的原因。最常见的是，状态为 0 意味着进程成功。然而，这不足以完全终止一个进程。父进程必须通过使用 `wait` 系统调用来确认子进程的终止，而这个调用的作用是检查子进程的终止状态。我知道这听起来有点残酷，但 `wait` 调用是必需的；毕竟，哪个父母不想知道他们的孩子是如何“死亡”的呢？

还有另一种终止进程的方法，那就是使用信号，我们很快就会讨论。

### Orphan Processes

当父进程在子进程之前“死亡”时，内核知道它不会收到 `wait` 调用，因此它会将这些进程变成“孤儿”，并将它们置于 `init` 的照管之下（记住，它是所有进程的“母亲”）。`init` 最终会为这些孤儿执行 `wait` 系统调用，以便它们可以“死亡”。

### Zombie Processes

当子进程终止而父进程尚未调用 `wait` 时会发生什么？我们仍然希望能够看到子进程是如何终止的，所以即使子进程已经完成，内核也会将子进程变成僵尸进程。子进程使用的资源仍然被释放以供其他进程使用；然而，进程表中仍然有这个僵尸进程的条目。僵尸进程也无法被杀死，因为它们在技术上已经“死亡”，所以你不能使用信号来杀死它们。最终，如果父进程调用 `wait` 系统调用，僵尸进程就会消失；这被称为“收割”。如果父进程不执行 `wait` 调用，`init` 将会“收养”僵尸进程并自动执行 `wait` 并移除僵尸进程。拥有过多的僵尸进程可能是一件坏事，因为它们会占用进程表中的空间；如果进程表被填满，它将阻止其他进程运行。

## Exercise

No exercises for this lesson.

## Quiz Question

进程成功的最常见终止状态是什么？

## Quiz Answer

0
