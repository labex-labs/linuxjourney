---
lang: "ko"
title: "프로세스 종료"
meta_description: "고아 및 좀비 프로세스를 포함하여 Linux 프로세스 종료에 대해 알아보세요. 효과적인 프로세스 관리를 위한 _exit 및 wait 시스템 호출을 이해하세요."
meta_keywords: "Linux 프로세스 종료, 좀비 프로세스, 고아 프로세스, wait 시스템 호출, _exit, Linux 튜토리얼, 초보자 Linux"
---

## Lesson Content

이제 프로세스가 생성될 때 어떤 일이 일어나는지 알았으니, 더 이상 필요 없을 때는 어떤 일이 일어날까요? 미리 경고하지만, 때로는 Linux 가 조금 어두워질 수 있습니다...

프로세스는 `_exit` 시스템 호출을 사용하여 종료할 수 있습니다. 이렇게 하면 해당 프로세스가 사용하던 리소스가 재할당을 위해 해제됩니다. 따라서 프로세스가 종료 준비가 되면, 종료 상태 (termination status) 라는 것을 통해 커널에 종료 이유를 알립니다. 가장 일반적으로, 상태 0 은 프로세스가 성공했음을 의미합니다. 그러나 이것만으로는 프로세스를 완전히 종료하기에 충분하지 않습니다. 부모 프로세스는 `wait` 시스템 호출을 사용하여 자식 프로세스의 종료를 승인해야 하며, 이는 자식 프로세스의 종료 상태를 확인합니다. 생각하기에 끔찍하지만, `wait` 호출은 필수적입니다. 결국, 어떤 부모가 자식이 어떻게 죽었는지 알고 싶어 하지 않겠습니까?

프로세스를 종료하는 또 다른 방법이 있으며, 이는 곧 논의할 시그널을 사용하는 것입니다.

### Orphan Processes

자식 프로세스보다 부모 프로세스가 먼저 죽으면, 커널은 `wait` 호출을 받지 못할 것을 알기 때문에 이 프로세스들을 "고아 (orphans)"로 만들고 `init` (모든 프로세스의 어머니를 기억하세요) 의 보살핌 아래 둡니다. `init`은 결국 이 고아들을 위해 `wait` 시스템 호출을 수행하여 그들이 죽을 수 있도록 합니다.

### Zombie Processes

자식이 종료되었는데 부모 프로세스가 아직 `wait`를 호출하지 않았다면 어떻게 될까요? 우리는 여전히 자식 프로세스가 어떻게 종료되었는지 볼 수 있기를 원하므로, 자식 프로세스가 완료되었음에도 불구하고 커널은 자식 프로세스를 좀비 프로세스로 만듭니다. 자식 프로세스가 사용했던 리소스는 다른 프로세스를 위해 여전히 해제되지만, 이 좀비에 대한 프로세스 테이블에는 여전히 항목이 남아 있습니다. 좀비 프로세스는 기술적으로 "죽은" 상태이므로 죽일 수 없으며, 따라서 시그널을 사용하여 죽일 수 없습니다. 결국, 부모 프로세스가 `wait` 시스템 호출을 호출하면 좀비는 사라집니다. 이를 "수확 (reaping)"이라고 합니다. 부모가 `wait` 호출을 수행하지 않으면, `init`이 좀비를 입양하고 자동으로 `wait`를 수행하여 좀비를 제거합니다. 좀비 프로세스가 너무 많으면 프로세스 테이블의 공간을 차지하므로 좋지 않을 수 있습니다. 프로세스 테이블이 가득 차면 다른 프로세스가 실행되는 것을 방해할 것입니다.

## Exercise

No exercises for this lesson.

## Quiz Question

프로세스 성공에 대한 가장 일반적인 종료 상태는 무엇입니까?

## Quiz Answer

0
