---
index: 5
lang: "ko"
title: "프로세스 종료"
meta_title: "프로세스 종료 - 프로세스"
meta_description: "Linux 프로세스 종료, 고아 및 좀비 프로세스에 대해 알아보세요. 효과적인 프로세스 관리를 위한 _exit 및 wait 시스템 호출을 이해하세요."
meta_keywords: "Linux 프로세스 종료, 좀비 프로세스, 고아 프로세스, wait 시스템 호출, _exit, Linux 튜토리얼, 초보자 Linux"
---

## Lesson Content

프로세스가 생성될 때 어떤 일이 일어나는지 알았으니, 더 이상 필요 없을 때는 어떤 일이 일어날까요? 미리 경고하지만, 때때로 Linux 는 조금 어두워질 수 있습니다.

프로세스는 `_exit` 시스템 호출을 사용하여 종료될 수 있습니다. 이렇게 하면 해당 프로세스가 사용하던 리소스가 재할당을 위해 해제됩니다. 따라서 프로세스가 종료될 준비가 되면, 종료 상태라는 것을 통해 커널에 종료 이유를 알립니다. 가장 일반적으로, 상태 0 은 프로세스가 성공했음을 의미합니다. 그러나 이것만으로는 프로세스를 완전히 종료하기에 충분하지 않습니다. 부모 프로세스는 `wait` 시스템 호출을 사용하여 자식 프로세스의 종료를 승인해야 하며, 이는 자식 프로세스의 종료 상태를 확인합니다. 생각하기에 끔찍하다는 것을 알지만, `wait` 호출은 필수적입니다. 결국, 어떤 부모가 자식이 어떻게 죽었는지 알고 싶어 하지 않겠습니까?

프로세스를 종료하는 또 다른 방법이 있으며, 이는 곧 논의할 시그널을 사용하는 것입니다.

### 고아 프로세스

부모 프로세스가 자식 프로세스보다 먼저 죽으면, 커널은 `wait` 호출을 받지 못할 것이라는 것을 알고, 대신 이 프로세스들을 "고아"로 만들고 `init` (모든 프로세스의 어머니를 기억하세요) 의 보살핌 아래 둡니다. `init`은 결국 이 고아들을 위해 `wait` 시스템 호출을 수행하여 그들이 죽을 수 있도록 합니다.

### 좀비 프로세스

자식이 종료되었는데 부모 프로세스가 아직 `wait`를 호출하지 않았다면 어떻게 될까요? 우리는 여전히 자식 프로세스가 어떻게 종료되었는지 볼 수 있기를 원하므로, 자식 프로세스가 완료되었음에도 불구하고 커널은 자식 프로세스를 좀비 프로세스로 만듭니다. 자식 프로세스가 사용했던 리소스는 다른 프로세스를 위해 여전히 해제되지만, 이 좀비를 위한 프로세스 테이블에는 여전히 항목이 있습니다. 좀비 프로세스는 기술적으로 "죽은" 상태이므로 죽일 수 없으며, 따라서 시그널을 사용하여 죽일 수 없습니다. 결국, 부모 프로세스가 `wait` 시스템 호출을 호출하면 좀비는 사라집니다. 이를 "회수 (reaping)"라고 합니다. 부모가 `wait` 호출을 수행하지 않으면, `init`이 좀비를 채택하고 자동으로 `wait`를 수행하여 좀비를 제거합니다. 좀비 프로세스가 너무 많으면 프로세스 테이블의 공간을 차지하므로 좋지 않을 수 있습니다. 프로세스 테이블이 가득 차면 다른 프로세스가 실행되는 것을 방해할 것입니다.

## Exercise

연습이 완벽을 만듭니다! 다음은 Linux 프로세스 및 해당 관리에 대한 이해를 강화하기 위한 실습 랩입니다:

1. **[Linux 프로세스 관리 및 모니터링](https://labex.io/ko/labs/comptia-manage-and-monitor-linux-processes-590864)** - 포그라운드 및 백그라운드 프로세스와 상호 작용하고, `ps`로 검사하고, `top`으로 리소스를 모니터링하고, `renice`로 우선순위를 조정하고, `kill`로 종료하는 연습을 합니다. 이 랩은 프로세스 수명 주기, 특히 프로세스를 종료하는 방법에 대한 실질적인 경험을 제공합니다.

이 랩은 실제 시나리오에서 프로세스 관리 및 종료 개념을 적용하고 Linux 시스템 관리 능력을 향상시키는 데 도움이 될 것입니다.

## Quiz Question

프로세스 성공에 대한 가장 일반적인 종료 상태는 무엇입니까?

## Quiz Answer

0
