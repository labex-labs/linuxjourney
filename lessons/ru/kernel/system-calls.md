---
index: 3
lang: "ru"
title: "Системные вызовы"
meta_title: "Системные вызовы - Ядро"
meta_description: "Узнайте о системных вызовах Linux (syscalls) и о том, как они взаимодействуют с ядром. Разберитесь в пользовательском режиме и режиме ядра, а также используйте `strace` для отладки. Начните свой путь в Linux!"
meta_keywords: "Системные вызовы Linux, syscalls, режим ядра, пользовательский режим, команда strace, учебник по Linux, Linux для начинающих, руководство по Linux"
---

## Lesson Content

Помните Бритни из предыдущего урока? Допустим, мы хотим увидеться с ней и выпить вместе. Как нам попасть из толпы людей снаружи в ее ближайший круг? Мы бы использовали системные вызовы. Системные вызовы — это как VIP-пропуска, которые ведут вас к секретной боковой двери, ведущей прямо к Бритни.

Системные вызовы (syscalls) предоставляют процессам пользовательского пространства способ запросить у ядра выполнение чего-либо для нас. Ядро предоставляет определенные службы через API системных вызовов. Эти службы позволяют нам читать или записывать файлы, изменять использование памяти, изменять нашу сеть и т. д. Количество служб фиксировано, поэтому вы не можете добавлять системные вызовы как попало. Ваша система уже имеет таблицу существующих системных вызовов, и каждый системный вызов имеет уникальный идентификатор.

Я не буду вдаваться в подробности системных вызовов, так как для этого потребуется знание C, но основы заключаются в том, что когда вы вызываете программу, такую как `ls`, код внутри этой программы содержит обертку системного вызова (то есть еще не сам системный вызов). Внутри этой обертки он вызывает системный вызов, который выполнит ловушку. Эта ловушка затем перехватывается обработчиком системных вызовов, который затем ссылается на системный вызов в таблице системных вызовов. Допустим, мы пытаемся вызвать системный вызов `stat()`; он идентифицируется по ID системного вызова, и цель системного вызова `stat()` — запросить статус файла. Теперь помните, вы запускали программу `ls` в непривилегированном режиме. Итак, теперь она видит, что вы пытаетесь сделать системный вызов, затем переключает вас в режим ядра. Там она делает много вещей, но самое главное, она ищет ваш номер системного вызова, находит его в таблице на основе ID системного вызова, а затем выполняет функцию, которую вы хотели запустить. Как только это будет сделано, она вернется в пользовательский режим, и ваш процесс получит статус возврата, если он был успешным или если произошла ошибка. Внутреннее устройство системных вызовов очень детализировано; я бы порекомендовал поискать информацию в Интернете, если вы хотите узнать больше.

Вы можете просмотреть системные вызовы, которые делает процесс, с помощью команды `strace`. Команда `strace` полезна для отладки выполнения программы.

```bash
strace ls
```

## Exercise

Практика ведет к совершенству! Хотя внутреннее устройство системных вызовов сложно, понимание того, как программы пользовательского пространства взаимодействуют с ядром, является фундаментальным. Лучший способ понять это взаимодействие — практиковаться с командами, которые выполняют эти базовые операции. Вот несколько практических заданий для закрепления вашего понимания взаимодействия с файловой системой, которое сильно зависит от системных вызовов:

1. **[Навигация по файловой системе в Linux](https://labex.io/ru/labs/comptia-navigate-the-filesystem-in-linux-590971)** - Практикуйте основные команды, такие как `ls`, `cd` и `pwd`, чтобы перемещаться и проверять файловую систему Linux, напрямую взаимодействуя со службами файловой системы ядра.
2. **[Управление файлами и каталогами в Linux](https://labex.io/ru/labs/comptia-manage-files-and-directories-in-linux-590835)** - Научитесь создавать, удалять, копировать и перемещать файлы и каталоги с помощью команд, таких как `mkdir`, `rm`, `cp` и `mv`, все из которых включают системные вызовы для выполнения своих действий.
3. **[Поиск файлов и команд в Linux](https://labex.io/ru/labs/comptia-find-files-and-commands-in-linux-590834)** - Освойте методы поиска файлов и команд с помощью `find`, `whereis` и `which`, что дополнительно иллюстрирует, как пользовательские команды используют службы ядра для взаимодействия с файловой системой.

Эти лабораторные работы помогут вам применить концепции взаимодействия с файловой системой в реальных сценариях и укрепить уверенность в основных операциях Linux, которые неявно зависят от системных вызовов.

## Quiz Question

Что используется для переключения из пользовательского режима в режим ядра?

## Quiz Answer

System call
