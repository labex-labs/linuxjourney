---
index: 4
lang: "ru"
title: "Создание процессов"
meta_title: "Создание процессов - Процессы"
meta_description: "Узнайте о создании процессов Linux, fork и родительских/дочерних процессах. Разберитесь с PID, PPID и процессом init. Получите руководство для начинающих по управлению процессами Linux."
meta_keywords: "Создание процессов Linux, fork, PID, PPID, процесс init, процессы Linux, для начинающих, учебник, руководство"
---

## Lesson Content

Опять же, этот и следующий уроки носят чисто информационный характер, чтобы вы могли увидеть, что находится «под капотом». Не стесняйтесь вернуться к этому, как только вы немного поработаете с процессами.

Когда создается новый процесс, существующий процесс, по сути, клонирует себя, используя так называемый системный вызов `fork` (системные вызовы будут обсуждаться очень далеко в будущем). Системный вызов `fork` создает почти идентичный дочерний процесс. Этот дочерний процесс получает новый идентификатор процесса (PID), а исходный процесс становится его родительским процессом и имеет так называемый идентификатор родительского процесса **PPID**. После этого дочерний процесс может либо продолжать использовать ту же программу, которую использовал его родитель, либо, что чаще, использовать системный вызов `execve` для запуска новой программы. Этот системный вызов уничтожает управление памятью, которое ядро установило для этого процесса, и настраивает новое для новой программы.

Мы можем увидеть это в действии:

```bash
ps l
```

Опция `l` дает нам «длинный формат» или еще более подробное представление о наших запущенных процессах. Вы увидите столбец с меткой **PPID**; это родительский идентификатор. Теперь посмотрите на свой терминал; вы увидите запущенный процесс, который является вашей оболочкой. Так, в моей системе у меня запущен процесс `bash`. Теперь вспомните, когда вы запускали команду `ps l`, вы запускали ее из процесса, который запускал `bash`. Вы увидите, что **PID** оболочки `bash` является **PPID** команды `ps l`.

Итак, если каждый процесс должен иметь родителя, и они просто являются форками друг друга, то должна быть мать всех процессов, верно? Вы правы. Когда система загружается, ядро создает процесс под названием **init**; он имеет PID 1. Процесс `init` не может быть завершен, если только система не выключится. Он запускается с правами root и запускает множество процессов, которые поддерживают работу системы. Мы более подробно рассмотрим `init` в курсе по загрузке системы; пока просто знайте, что это процесс, который порождает все остальные процессы.

## Exercise

Практика ведет к совершенству! Вот практическая лабораторная работа для закрепления вашего понимания процессов Linux и их управления:

- **[Управление и мониторинг процессов Linux](https://labex.io/ru/labs/comptia-manage-and-monitor-linux-processes-590864)** - В этой лабораторной работе вы изучите основные навыки управления и мониторинга процессов в системе Linux. Вы узнаете, как взаимодействовать с фоновыми и передними процессами, проверять их с помощью `ps`, отслеживать ресурсы с помощью `top`, настраивать приоритет с помощью `renice` и завершать их с помощью `kill`.

Эта лабораторная работа поможет вам применить концепции идентификаторов процессов, идентификаторов родительских процессов и мониторинга процессов в реальном сценарии и укрепить уверенность в управлении процессами.

## Quiz Question

Какой системный вызов создает новый процесс?

## Quiz Answer

fork
