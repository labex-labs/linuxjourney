---
lang: "ru"
title: "Завершение процессов"
meta_description: "Узнайте о завершении процессов Linux, включая процессы-сироты и зомби. Изучите системные вызовы _exit и wait для эффективного управления процессами."
meta_keywords: "Завершение процессов Linux, зомби-процессы, процессы-сироты, системный вызов wait, _exit, учебник по Linux, Linux для начинающих"
---

## Lesson Content

Теперь, когда мы знаем, что происходит при создании процесса, что происходит, когда он нам больше не нужен? Будьте осторожны, иногда Linux может быть немного мрачным...

Процесс может завершиться с помощью системного вызова `_exit`. Это освободит ресурсы, которые использовал процесс, для перераспределения. Итак, когда процесс готов к завершению, он сообщает ядру, почему он завершается, с помощью так называемого статуса завершения. Чаще всего статус 0 означает, что процесс завершился успешно. Однако этого недостаточно для полного завершения процесса. Родительский процесс должен подтвердить завершение дочернего процесса, используя системный вызов `wait`, и это проверяет статус завершения дочернего процесса. Я знаю, что об этом жутко думать, но вызов `wait` необходим; в конце концов, какой родитель не захочет знать, как умер его ребенок?

Существует еще один способ завершить процесс, и это включает использование сигналов, которые мы скоро обсудим.

### Orphan Processes

Когда родительский процесс умирает раньше дочернего процесса, ядро знает, что оно не получит вызов `wait`, поэтому вместо этого оно делает эти процессы «сиротами» и передает их под опеку `init` (помните, матери всех процессов). `init` в конечном итоге выполнит системный вызов `wait` для этих сирот, чтобы они могли умереть.

### Zombie Processes

Что происходит, когда дочерний процесс завершается, а родительский процесс еще не вызвал `wait`? Мы все еще хотим иметь возможность видеть, как завершился дочерний процесс, поэтому, хотя дочерний процесс завершился, ядро превращает дочерний процесс в зомби-процесс. Ресурсы, использованные дочерним процессом, все еще освобождаются для других процессов; однако в таблице процессов для этого зомби все еще есть запись. Зомби-процессы также не могут быть убиты, поскольку они технически «мертвы», поэтому вы не можете использовать сигналы для их уничтожения. В конце концов, если родительский процесс вызывает системный вызов `wait`, зомби исчезнет; это известно как «сбор урожая». Если родитель не выполняет вызов `wait`, `init` усыновит зомби и автоматически выполнит `wait` и удалит зомби. Наличие слишком большого количества зомби-процессов может быть плохой вещью, поскольку они занимают место в таблице процессов; если она заполнится, это помешает запуску других процессов.

## Exercise

No exercises for this lesson.

## Quiz Question

Какой наиболее распространенный статус завершения для успешно завершившегося процесса?

## Quiz Answer

0
