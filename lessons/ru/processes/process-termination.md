---
index: 5
lang: "ru"
title: "Завершение процессов"
meta_title: "Завершение процессов - Процессы"
meta_description: "Узнайте о завершении процессов Linux, включая процессы-сироты и зомби. Изучите системные вызовы _exit и wait для эффективного управления процессами."
meta_keywords: "Завершение процессов Linux, процессы-зомби, процессы-сироты, системный вызов wait, _exit, учебник по Linux, Linux для начинающих"
---

## Lesson Content

Теперь, когда мы знаем, что происходит при создании процесса, что происходит, когда он нам больше не нужен? Будьте осторожны, иногда Linux может быть немного мрачным...

Процесс может завершиться с помощью системного вызова `_exit`. Это освободит ресурсы, которые использовал процесс, для перераспределения. Итак, когда процесс готов к завершению, он сообщает ядру, почему он завершается, с помощью так называемого статуса завершения. Чаще всего статус 0 означает, что процесс завершился успешно. Однако этого недостаточно для полного завершения процесса. Родительский процесс должен подтвердить завершение дочернего процесса, используя системный вызов `wait`, и это проверяет статус завершения дочернего процесса. Я знаю, что об этом жутко думать, но вызов `wait` необходим; в конце концов, какой родитель не захочет знать, как умер его ребенок?

Есть еще один способ завершить процесс, и это использование сигналов, которые мы скоро обсудим.

### Процессы-сироты

Когда родительский процесс умирает раньше дочернего процесса, ядро знает, что оно не получит вызов `wait`, поэтому вместо этого оно делает эти процессы «сиротами» и передает их под опеку `init` (помните, мать всех процессов). `init` в конечном итоге выполнит системный вызов `wait` для этих сирот, чтобы они могли умереть.

### Процессы-зомби

Что происходит, когда дочерний процесс завершается, а родительский процесс еще не вызвал `wait`? Мы все еще хотим иметь возможность видеть, как завершился дочерний процесс, поэтому, хотя дочерний процесс завершился, ядро превращает дочерний процесс в процесс-зомби. Ресурсы, использованные дочерним процессом, все еще освобождаются для других процессов; однако в таблице процессов для этого зомби все еще есть запись. Процессы-зомби также не могут быть убиты, поскольку они технически «мертвы», поэтому вы не можете использовать сигналы для их уничтожения. В конечном итоге, если родительский процесс вызывает системный вызов `wait`, зомби исчезнет; это известно как «сбор урожая». Если родитель не выполняет вызов `wait`, `init` усыновит зомби и автоматически выполнит `wait` и удалит зомби. Наличие слишком большого количества процессов-зомби может быть плохой вещью, поскольку они занимают место в таблице процессов; если она заполнится, это помешает запуску других процессов.

## Exercise

Практика ведет к совершенству! Вот несколько практических заданий для закрепления вашего понимания процессов Linux и их управления:

1. **[Управление и мониторинг процессов Linux](https://labex.io/ru/labs/comptia-manage-and-monitor-linux-processes-590864)** - Практикуйтесь во взаимодействии с процессами переднего и заднего плана, их проверке с помощью `ps`, мониторинге ресурсов с помощью `top`, настройке приоритета с помощью `renice` и их завершении с помощью `kill`. Эта лаборатория даст вам практический опыт работы с жизненным циклом процессов, включая способы их завершения.

Эта лаборатория поможет вам применить концепции управления и завершения процессов в реальных сценариях и укрепить уверенность в администрировании систем Linux.

## Quiz Question

Каков наиболее распространенный статус завершения для успешно завершившегося процесса?

## Quiz Answer

0
